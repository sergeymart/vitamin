{-# STDLIB_VERSION 5 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

let precision = 1000000000000000000

func keyManagerPublicKey() = getString("managerPublicKey")

func managerPublicKeyOrUnit() = match keyManagerPublicKey() {
  case s: String => s.fromBase58String()
  case _: Unit => unit
}

func mustManager(i: Invocation) = {
  let pd = "permission denied".throw()

  match managerPublicKeyOrUnit() {
    case pk: ByteVector => i.callerPublicKey == pk || pd
    case _: Unit => i.caller == this || pd
  }
}

func mustNotInited() = {
  match getBoolean("inited") {
    case inited: Boolean => inited == false || throw("Already inited")
    case _: Unit => false
  }
}

func cancelLease() = {
  match getBinary("leaseId") {
    case id: ByteVector => [LeaseCancel(id), DeleteEntry("leaseId")]
    case _: Unit => []
  }
}

func getBalance() = {
  getInteger("balance").valueOrElse(0)
}

func setBalance(amount: Int) = {
  IntegerEntry("balance", amount)
}

func lease(amount: Int) = {
  if (amount == 0) then [] else

  let leaserAddress = Address(fromBase58String(getStringValue("leaserAddress")))
  let currentAmount = getBalance()
  let newAmount = currentAmount + amount

  let leaseActions = if (newAmount > 0) then {
    let newLease = Lease(leaserAddress, newAmount)
    let newLeaseId = calculateLeaseId(newLease)
    [newLease, BinaryEntry("leaseId", newLeaseId)]
  } else []

  cancelLease() ++ leaseActions :+ setBalance(newAmount)
}

func issueSWaves(amount: Int) = {
  let sWavesAssetId = getStringValue("sWavesAssetId").fromBase58String()
  Reissue(sWavesAssetId, amount, true)
}

func burnSWaves(amount: Int) = {
  let sWavesAssetId = getStringValue("sWavesAssetId").fromBase58String()
  Burn(sWavesAssetId, amount)
}

func sendSWaves(recipient: Address, amount: Int) = {
  let sWavesAssetId = getStringValue("sWavesAssetId").fromBase58String()
  ScriptTransfer(recipient, amount, sWavesAssetId)
}

func sendWaves(recipient: Address, amount: Int) = {
  ScriptTransfer(recipient, amount, unit)
}

func sWavesQuantity() = {
  let assetId = getStringValue("sWavesAssetId").fromBase58String()
  match assetInfo(assetId) {
    case asset: Asset => asset.quantity
    case _ => throw("Can't find asset")
  }
}

func getExcessWaves() = {
  let leaserAddress = Address(fromBase58String(getStringValue("leaserAddress")))
  wavesBalance(leaserAddress).regular
}

func setRate(rate: Int, growthRate: Int) = {
  [
    IntegerEntry("lastRate", rate),
    IntegerEntry("lastTimestamp", lastBlock.timestamp),
    IntegerEntry("growthRate", growthRate)
  ]
}

func withdraw() = {
  let minerAddress = Address(fromBase58String(getStringValue("leaserAddress")))
  strict result = invoke(minerAddress, "withdraw", [], [])
  result
}

func currentRate(dt: Int) = {
  getIntegerValue("lastRate") + getIntegerValue("growthRate") * dt
}

func getCompoundTimestampDiff() = {
  lastBlock.timestamp - getIntegerValue("lastTimestamp")
}

@Callable(i)
func init(leaserAddress: String) = {
  strict checks = [
    mustManager(i),
    mustNotInited()
  ]

  let sWaves = Issue("sWaves", "", 0, 8, true, unit, 0)
  let sWavesAssetId = sWaves.calculateAssetId()
  [
    BooleanEntry("inited", true),
    StringEntry("sWavesAssetId",  sWavesAssetId.toBase58String()),
    StringEntry("leaserAddress",  leaserAddress),
    IntegerEntry("lastRate", precision),
    IntegerEntry("lastTimestamp", lastBlock.timestamp),
    IntegerEntry("growthRate", 0),
    IntegerEntry("balance", 0),
    sWaves
  ]
}

@Callable(i)
func compound() = {
  let dt = getCompoundTimestampDiff()
  let sWavesTotal = sWavesQuantity()

  if (dt == 0 || sWavesTotal == 0) then [] else

  let rate = currentRate(dt)
  strict excessWaves = getExcessWaves()
  
  let growthRate = fraction(excessWaves, precision, sWavesTotal) / 86400000

  strict withdrawResult = withdraw()
  
  lease(excessWaves) ++ setRate(rate, growthRate)
}

@Callable(i)
func stake() = {
  let payment = i.payments[0]
  if (payment.assetId != unit) then throw("Only WAVES supported") else
  if (size(i.payments) != 1) then throw("Wrong payments amount") else

  let dt = getCompoundTimestampDiff()
  let rate = currentRate(dt)
  let toReissue = fraction(payment.amount, precision, rate)

  strict result = invoke(this, "compound", [], [])

  lease(payment.amount) :+ issueSWaves(toReissue) :+ sendSWaves(i.caller, toReissue)
}

@Callable(i)
func unstake() = {
  let payment = i.payments[0]
  let sWavesAssetId = fromBase58String(getStringValue("sWavesAssetId"))
  if (payment.assetId != sWavesAssetId) then throw("Only sWAVES supported") else
  if (size(i.payments) != 1) then throw("Wrong payments amount") else

  let dt = getCompoundTimestampDiff()
  let rate = currentRate(dt)
  let transferAmount = fraction(payment.amount, rate, precision)

  strict result = invoke(this, "compound", [], [])

  lease(-transferAmount) :+ burnSWaves(payment.amount) :+ sendWaves(i.caller, transferAmount) 
}


@Verifier(tx)
func verify() = sigVerify(tx.bodyBytes, tx.proofs[0], tx.senderPublicKey)
        